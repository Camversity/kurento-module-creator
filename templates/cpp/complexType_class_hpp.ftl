cpp/${complexType.name}.hpp
/* Autogenerated with Kurento Idl */

#ifndef __${camelToUnderscore(complexType.name)}_HPP__
#define __${camelToUnderscore(complexType.name)}_HPP__

#include <jsoncpp/json/json.h>
#include <JsonRpcException.hpp>

class JsonSerializer;

namespace kurento {

class ${complexType.name}
{

public:
  virtual void Serialize(JsonSerializer& s);

<#if complexType.typeFormat == "REGISTER">
  ${complexType.name} (<#rt>
    <#lt><#list complexType.properties as property><#rt>
      <#lt><#if !property.optional><#rt>
        <#lt><#if (first) ??>, </#if><#rt>
        <#lt><#assign first = true><#rt>
        <#lt>${getCppObjectType(property.type.name)} ${property.name}<#rt>
      <#lt></#if><#rt>
    <#lt></#list>){
    <#list complexType.properties as property><#rt>
      <#lt><#if !property.optional><#rt>
    this->${property.name} = ${property.name};
      </#if><#rt>
    <#lt></#list>
  };

  ${complexType.name} (const Json::Value &value) throw (JsonRpc::CallException);

  <#list complexType.properties as property>
  void set${property.name?cap_first} (${getCppObjectType(property.type.name, false)} ${property.name}) {
    this->${property.name} = ${property.name};
    <#if property.optional>
    _isSet${property.name?cap_first} = true;
    </#if>
  };

  ${getCppObjectType(property.type.name)} get${property.name?cap_first} () {
    return ${property.name};
  };

  <#if property.optional>
  bool isSet${property.name?cap_first} () {
    return _isSet${property.name?cap_first};
  };

  </#if>
  </#list>
private:
  <#list complexType.properties as property>
  ${getCppObjectType(property.type.name, false)} ${property.name};
  <#if property.optional>
  bool _isSet${property.name?cap_first} = false;
  </#if>
  </#list>
<#elseif complexType.typeFormat == "ENUM">
  typedef enum {
  <#list complexType.values as value>
    ${value}<#if value_has_next>,</#if>
  </#list>
  } type;

  ${complexType.name} (const std::string &type) {

    <#list complexType.values as value>
    if (type ==  "${value}") {
      enumValue = ${value};
    }

    </#list>
  };

  ${complexType.name} (type value) {
    this->enumValue = value;
  }

  type getValue () {
    return enumValue;
  };

  std::string getString () {

    <#list complexType.values as value>
    if (enumValue ==  ${value}) {
      return "${value}";
    }

    </#list>
    return "";
  }

private:

  type enumValue;

<#else>
// TODO: Type format ${complexType.typeFormat} not supported
</#if>
};

} /* kurento */

#endif /*  __${camelToUnderscore(complexType.name)}_HPP__ */
