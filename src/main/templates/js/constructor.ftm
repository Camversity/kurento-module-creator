<#switch remoteClass.name>
  <#case "MediaObject">


  //
  // Define object properties
  //

  /**
   * Unique identifier of this object
   *
   * @public
   * @readonly
   * @member {external:Number} id
   */
  this.then(function(id)
  {
    Object.defineProperty(this, 'id', {value: id});
  })


  //
  // Subscribe and unsubscribe events on the server when adding and removing
  // event listeners on this MediaObject
  //

  var subscriptions = {};

  this.on('removeListener', function(event, listener)
  {
    // Blacklisted events
    if(event[0] == '_'
    || event == 'release'
    || event == 'newListener')
      return;

    var count = EventEmitter.listenerCount(this, event);
    if(count) return;

    var token = subscriptions[event];

    this.emit('_rpc', 'unsubscribe', {subscription: token}, function(error)
    {
      if(error) return this.emit('error', error);

      delete subscriptions[event];
    });
  });

  this.on('newListener', function(event, listener)
  {
    // Blacklisted events
    if(event[0] == '_'
    || event == 'release')
      return;

    var constructor = this.constructor;

    if(constructor.events.indexOf(event) < 0)
      throw new SyntaxError(constructor.name+" doesn't accept events of type '"
                            +event+"'")

    var count = EventEmitter.listenerCount(this, event);
    if(count) return;

    this.emit('_rpc', 'subscribe', {type: event}, function(error, token)
    {
      if(error) return this.emit('error', error);

      subscriptions[event] = token;
    });
  });
  <#break>
  <#case "MediaPipeline">


  var self = this;

  var transactions = [];

  function transactionOperation(method, mediaObject, params, callback)
  {
    var message =
    {
      method: method,
      mediaObject: mediaObject,
      params: params,
      callback: callback
    }

    transactions[0].push(message);
  }

  function beginTransaction()
  {
    transactions.unshift([]);
  };

  function endTransaction(callback)
  {
    var operations = transactions.shift();

    if(transactions.length)
    {
      var params =
      {
        operations: operations
      }

      transactionOperation('transaction', params, callback);
    }
    else
      self.emit('_commit', operations, function(error, result)
      {
        if(error) return callback(error);

        callback(null, result);
      });
  };

  this.transaction = function(transaction, callback)
  {
    var ctx = {};

    beginTransaction();
    transaction.call(this, ctx);
    endTransaction();

    if(callback)
      callback.call(this, ctx);
  };


  function encodeCreate(mediaObject, params, callback)
  {
    if(self.id != undefined)
      self.emit('_create', mediaObject, params, callback)
    else
      transactionOperation('create', mediaObject, params, callback);
  }

  /**
   * Request to the server to create a new MediaElement
   */
  function createMediaObject(item, callback)
  {
    var constructor = getConstructor(item.type);

    if(constructor.create)
    {
      item = constructor.create(item.params);

      // Apply inheritance
      var prototype = constructor.prototype;
      inherits(constructor, getConstructor(item.type));
      extend(constructor.prototype, prototype);
    };

    item.params.mediaPipeline = self;

    item.constructorParams = checkParams(item.params,
                                         constructor.constructorParams,
                                         item.type);
    delete item.params;

    var mediaObject = new constructor()

    /**
     * Request a generic functionality to be procesed by the server
     */
    mediaObject.on('_rpc', function(method, params, callback)
    {
      params.object = mediaObject;

      if(self.id != undefined)
        self.emit('_rpc', method, params, callback)
      else
        transactionOperation(method, mediaObject, params, callback);
    });

    if(mediaObject instanceof register.abstracts.Hub)
      mediaObject.on('_create', encodeCreate);

    encodeCreate(mediaObject, item, callback);

    return mediaObject
  };

  /**
   * Create a new instance of a {module:core/abstract.MediaObject} attached to
   *  this {module:core.MediaPipeline}
   *
   * @param {external:String} type - Type of the
   *  {module:core/abstract.MediaObject}
   * @param {external:String[]} [params]
   * @param {module:core.MediaPipeline~createCallback} callback
   *
   * @return {external:Promise}
   */
  this.create = function(type, params, callback){
    // Fix optional parameters
    if(params instanceof Function){
      if(callback)
        throw new SyntaxError("Nothing can be defined after the callback");

      callback = params;
      params = undefined;
    };

    params = params || {};

    if(type instanceof Array)
      return createPromise(type, createMediaObject, callback)

    type = {params: params, type: type};

    return createMediaObject(type, callback)
  };
  /**
   * @callback core.MediaPipeline~createCallback
   * @param {external:Error} error
   * @param {module:core/abstract~MediaElement} result
   *  The created MediaElement
   */

  /**
   * Start a {@link module:core/MediaPipeline MediaPipeline}
   *
   * @return {external:Promise}
   */
  this.start = function(callback){
//    if(this.id != undefined)
//      throw new SyntaxError('Called start() on an active MediaPipeline');

    var traces = transactions.length;
    if(traces != 1)
      throw new SyntaxError('Bad transactions stack (found '+traces+' traces)')

    endTransaction(callback);
  }
  /**
   * @callback core.MediaPipeline~startCallback
   * @param {external:Error} error
   */

//  beginTransaction();
  <#break>
</#switch>
