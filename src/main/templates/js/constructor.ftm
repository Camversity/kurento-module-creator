<#switch remoteClass.name>
  <#case "MediaObject">


  //
  // Define object properties
  //

  /**
   * Unique identifier of this object
   *
   * @public
   * @readonly
   * @member {external:Number} id
   */
  this.once('_id', function(error, id)
  {
    if(error) return Object.defineProperty(this, 'id', {value: null});

    Object.defineProperty(this, 'id', {value: id, enumerable: true});
  })

  //
  // Subscribe and unsubscribe events on the server when adding and removing
  // event listeners on this MediaObject
  //

  var subscriptions = {};

  this.on('removeListener', function(event, listener)
  {
    // Blacklisted events
    if(event[0] == '_'
    || event == 'release'
    || event == 'newListener')
      return;

    var count = EventEmitter.listenerCount(this, event);
    if(count) return;

    var token = subscriptions[event];

    this.emit('_rpc', 'unsubscribe', {subscription: token}, function(error)
    {
      if(error) return this.emit('error', error);

      delete subscriptions[event];
    });
  });

  this.on('newListener', function(event, listener)
  {
    // Blacklisted events
    if(event[0] == '_'
    || event == 'release')
      return;

    var constructor = this.constructor;

    if(constructor.events.indexOf(event) < 0)
      throw new SyntaxError(constructor.name+" doesn't accept events of type '"+event+"'")

    var count = EventEmitter.listenerCount(this, event);
    if(count) return;

    this.emit('_rpc', 'subscribe', {type: event}, function(error, token)
    {
      if(error) return this.emit('error', error);

      subscriptions[event] = token;
    });
  });
  <#break>
  <#case "MediaPipeline">


  var self = this;


  // Transactional API

  var transactions = [];

  function transactionOperation(method, params, callback)
  {
    var message =
    {
      method: method,
      params: params,
      callback: callback
    }

    transactions[0].push(message);
  }

  this.beginTransaction = function()
  {
    transactions.unshift([]);
  };

  this.endTransaction = function(callback)
  {
    var operations = transactions.shift();

    var promise = new Promise(function(resolve, reject)
    {
      function callback(error, result)
      {
        if(error) return reject(error);

        resolve(result)
      };

      encodeTransaction({operations: operations}, callback);
    })

    return promiseCallback(promise, callback)
  };

  this.transaction = function(transaction, callback)
  {
    this.beginTransaction();
    transaction.call(this);
    return this.endTransaction(callback);
  };


  // Encode commands

  function encodeCreate(params, callback)
  {
    if(transactions.length)
      transactionOperation('create', params, callback);
    else
      self.emit('_create', params, callback)
  }

  function encodeRpc(method, params, callback)
  {
    if(transactions.length)
      transactionOperation(method, params, callback);
    else
      self.emit('_rpc', method, params, callback)
  }

  function encodeTransaction(params, callback)
  {
    if(transactions.length)
      transactionOperation('transaction', params, callback);
    else
      self.then(function()
      {
        params.object = self.id;

        self.emit('_transaction', params, callback);
      })
  }


  /**
   * Request to the server to create a new MediaElement
   */
  function createMediaObject(item, callback)
  {
    var constructor = getConstructor(item.type);

    if(constructor.create)
    {
      item = constructor.create(item.params);

      // Apply inheritance
      var prototype = constructor.prototype;
      inherits(constructor, getConstructor(item.type));
      extend(constructor.prototype, prototype);
    };

    item.params.mediaPipeline = self;

    item.constructorParams = checkParams(item.params,
                                         constructor.constructorParams,
                                         item.type);
    delete item.params;

    var mediaObject = new constructor()

    /**
     * Request a generic functionality to be procesed by the server
     */
    mediaObject.on('_rpc', function(method, params, callback)
    {
      params.object = mediaObject;

      encodeRpc(method, params, callback);
    });

    if(mediaObject instanceof Hub)
      mediaObject.on('_create', encodeCreate);

    Object.defineProperty(item, 'object', {value: mediaObject});

    encodeCreate(item, callback);

    return mediaObject
  };

  /**
   * Create a new instance of a {module:core/abstract.MediaObject} attached to
   *  this {module:core.MediaPipeline}
   *
   * @param {external:String} type - Type of the
   *  {module:core/abstract.MediaObject}
   * @param {external:String[]} [params]
   * @param {module:core.MediaPipeline~createCallback} callback
   *
   * @return {external:Promise}
   */
  this.create = function(type, params, callback){
    // Fix optional parameters
    if(params instanceof Function){
      if(callback)
        throw new SyntaxError("Nothing can be defined after the callback");

      callback = params;
      params = undefined;
    };

    params = params || {};

    if(type instanceof Array)
      return createPromise(type, createMediaObject, callback)

    type = {params: params, type: type};

    return createMediaObject(type, callback)
  };
  /**
   * @callback core.MediaPipeline~createCallback
   * @param {external:Error} error
   * @param {module:core/abstract~MediaElement} result
   *  The created MediaElement
   */
  <#break>
</#switch>
