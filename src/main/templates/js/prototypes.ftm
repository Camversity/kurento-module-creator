<#switch remoteClass.name>
  <#case "Hub">

/**
 * Create a new instance of a {module:core~HubPort} attached to this {module:core~Hub}
 *
 * @param {module:core/abstract.Hub~createHubCallback} callback
 *
 * @return {external:Promise}
 */
Hub.prototype.createHubPort = function(callback){
  var transaction = (arguments[0] instanceof Transaction)
                  ? Array.prototype.shift.apply(arguments)
                  : undefined;

  if(!arguments.length) callback = undefined;

  var mediaObject = new HubPort()

  var params =
  {
    type: 'HubPort',
    hub: this
  };

  Object.defineProperty(params, 'object', {value: mediaObject});

  this.emit('_create', transaction, params, callback);

  return mediaObject
};
/**
 * @callback core/abstract.Hub~createHubCallback
 * @param {external:Error} error
 * @param {module:core/abstract.HubPort} result
 *  The created HubPort
 */

  <#break>
  <#case "MediaObject">

/**
 * Send a command to a media object
 *
 * @param {external:String} method - Command to be executed by the server
 * @param {module:core/abstract.MediaObject.constructorParams} [params]
 * @param {module:core/abstract.MediaObject~invokeCallback} callback
 *
 * @return {external:Promise}
 */
MediaObject.prototype._invoke = function(transaction, method, params, callback){
  var self = this;

  // Fix optional parameters
  if(params instanceof Function)
  {
    if(callback)
      throw new SyntaxError("Nothing can be defined after the callback");

    callback = params;
    params = undefined;
  };

  var promise = new Promise(function(resolve, reject)
  {
    // Generate request parameters
    var params2 =
    {
      object: self,
      operation: method
    };

    if(params)
      params2.operationParams = params;

    function callback(error, result)
    {
      if(error) return reject(error);

      var value = result.value;
      if(value === undefined) value = self;

      resolve(value);
    }

    // Do request
    self.emit('_rpc', transaction, 'invoke', params2, callback);
  });

  return promiseCallback(promise, callback);
};
/**
 * @callback core/abstract.MediaObject~invokeCallback
 * @param {external:Error} error
 */

/**
 * Explicity release a {@link module:core/abstract.MediaObject MediaObject} from memory
 *
 * All its descendants will be also released and collected
 *
 * @param {module:core/abstract.MediaObject~releaseCallback} callback
 *
 * @return {external:Promise}
 */
MediaObject.prototype.release = function(callback){
  var transaction = (arguments[0] instanceof Transaction)
                  ? Array.prototype.shift.apply(arguments)
                  : undefined;

  if(!arguments.length) callback = undefined;

  var self = this;

  var promise = new Promise(function(resolve, reject)
  {
    var params =
    {
      object: self
    };

    function callback(error)
    {
      if(error) return reject(error);

      self.emit('release');

      // Remove events on the object and remove object from cache
      self.removeAllListeners();

      resolve();
    }

    self.emit('_rpc', transaction, 'release', params, callback);
  });

  return promiseCallback(promise, callback);
};
/**
 * @callback core/abstract.MediaObject~releaseCallback
 * @param {external:Error} error
 */


// Promise interface ("thenable")

MediaObject.prototype.then = function(onFulfilled, onRejected){
  var self = this;

  return new Promise(function(resolve, reject)
  {
    function success(id)
    {
      var result;

      if(onFulfilled)
        try
        {
          result = onFulfilled.call(self, id);
        }
        catch(exception)
        {
          if(!onRejected)
            console.trace('Uncaugh exception', exception)

          return reject(exception);
        }

      resolve(result);
    };
    function failure(error)
    {
      var result = new Error(error);

      if(onRejected)
        try
        {
          result = onRejected.call(self, result);
        }
        catch(exception)
        {
          return reject(exception);
        }
      else
        console.trace('Uncaugh exception', result)

      reject(result);
    };

    if(self.id === null)
      failure()
    else if(self.id !== undefined)
      success(self)
    else
      self.once('_id', function(error, id)
      {
        if(error) return failure(error);

        success(self);
      })
  })
}

  <#break>
  <#case "MediaSource">

/**
 * Disconnect this source pad from the specified sink pad
 *
 * @public
 *
 * @param {...module:core/abstract.MediaSink} sink - Sink to be disconnected
 * @param {module:core/abstract.MediaSource~disconnectCallback} callback
 *
 * @return {external:Promise}
 */
MediaSource.prototype.disconnect = function(sink, callback){
  var transaction = (arguments[0] instanceof Transaction)
                  ? Array.prototype.shift.apply(arguments)
                  : undefined;

  if(arguments.length === 1) callback = undefined;

  checkType('MediaSink', 'sink', sink, {required: true});

  var params =
  {
    src: this
  };

  return sink._invoke(transaction, 'disconnect', params, callback);
};
/**
 * @callback module:core/abstract.MediaSource~disconnectCallback
 * @param {external:Error} error
 */

  <#break>
</#switch>
